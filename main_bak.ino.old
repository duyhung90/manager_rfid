#include <ESP8266WiFi.h>
#include <WiFiUdp.h>
#include <SPI.h>
#include <stdint.h>
#include "MFRC522.h"

/* wiring the MFRC522 to ESP8266 (ESP-12)
RST     = GPIO5
SDA(SS) = GPIO4
MOSI    = GPIO13
MISO    = GPIO12
SCK     = GPIO14
GND     = GND
3.3V    = 3.3V
*/

#define RST_PIN                 5  // RST-PIN für RC522 - RFID - SPI - Modul GPIO5
#define SS_PIN                  16  // SDA-PIN für RC522 - RFID - SPI - Modul GPIO4

#define DATA_PIN                4
#define CLK_PIN                 15
#define LATCH_PIN               2

#define BTN_PIN                 0

#define LED_UPDATE_INTERVAL     5 // 5 ms
#define CARD_SCAN_INTERLVAL     100 // 0,5 s
#define ONE_MINUTE              1200 //60000 // 60k ms
#define WASH_TIME               35 // 35 min

typedef struct{
    byte   uid[];
    byte    uidSize;
} card_uid_t;
//String tagID= "A1 32 71 8B";
String tagID= "20 12 F1 19";

const char *ssid =  "Buffalo-G-2490";     // change according to your Network - cannot be longer than 32 characters!
const char *pass =  "Passthang9"; // change according to your Network

char packetBuffer[255];          // buffer to hold incoming packet

//const uint8_t number[10] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F}; // katot chung
const uint8_t number[10] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90}; // anot chung

bool isStarted = false;
bool state_role = false;
volatile byte state_button = false;

byte card_uid[4] = {0xA1, 0x32, 0x71, 0x8B};

uint8_t cardNotFoundCount = 0;
uint8_t cardFoundCount  = 0;

uint32_t prevLedUpdateTime = 0;
uint32_t prevCardScanTime = 0;
uint32_t prevMinuteTime = 0;
uint32_t washTime = 0;

uint8_t ledData = 0;
uint8_t ledCtrlData = 0;
uint8_t ledPos = 0;

MFRC522 mfrc522(SS_PIN, RST_PIN); // Create MFRC522 instance

WiFiUDP udp;
IPAddress broadcastIp;

void setup() {
    Serial.begin(9600);    // Initialize serial communications
    delay(100);
    Serial.println("Booting....");

    SPI.begin();           // Init SPI bus
    mfrc522.PCD_Init();    // Init MFRC522

    // Init pin
    pinMode(DATA_PIN, OUTPUT);
    pinMode(CLK_PIN, OUTPUT);
    pinMode(LATCH_PIN, OUTPUT);
    pinMode(BTN_PIN, INPUT_PULLUP);
    //attachInterrupt(digitalPinToInterrupt(BTN_PIN), btnHandler, FALLING );

    digitalWrite(DATA_PIN, LOW);
    digitalWrite(CLK_PIN, LOW);
    digitalWrite(LATCH_PIN, LOW);

    // setRelayEnable(false);

   WiFi.begin(ssid, pass);

   int retries = 0;
   while ((WiFi.status() != WL_CONNECTED) && (retries < 10)) {
     retries++;
     delay(500);
     Serial.print(".");
   }
   if (WiFi.status() == WL_CONNECTED) {
     Serial.println(F("WiFi connected"));
     Serial.println(WiFi.localIP());
     broadcastIp = ~WiFi.subnetMask() | WiFi.gatewayIP();
     Serial.println(broadcastIp);
   }

    udp.begin(6789);

    Serial.println(F("Ready!"));
    Serial.println(F("======================================================"));

}

void btnHandler(void)
{
    static byte i = false;
    if(state_role == true) state_role = false;
    else state_role = true;

    setRelayEnable(bool(state_role));
    state_button=true;
}

void loop() {

    uint32_t curTime = millis();

    // update led
    if (curTime - prevLedUpdateTime >= LED_UPDATE_INTERVAL)
    {
        prevLedUpdateTime = curTime;
        ledUpdate();
    }

//    if (state_button == true)
//    {
//      Serial.println("Down....");
//      state_button = false;
//    }
    // scan card
    if (curTime - prevCardScanTime >= CARD_SCAN_INTERLVAL) // every 0.5s
    //if (0)
    {
        prevCardScanTime = curTime;

        if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial())
        {
            //Show UID on serial monitor
            //Serial.print("UID tag :");
            String content= "";
            byte letter;
            for (byte i = 0; i < mfrc522.uid.size; i++)
            {
               Serial.print(mfrc522.uid.uidByte[i] < 0x10 ? " 0" : " ");
               Serial.print(mfrc522.uid.uidByte[i], HEX);
            }
            Serial.println();
            if (WiFi.status() == WL_CONNECTED)
            {
              udp.beginPacket(broadcastIp, 6789);
              udp.write("hello");
              udp.endPacket();
            }
        }
    }

  int packetSize = udp.parsePacket();
  if (packetSize) {
    Serial.print("Received packet of size ");
    Serial.println(packetSize);
    Serial.print("From ");
    IPAddress remoteIp = udp.remoteIP();
    Serial.print(remoteIp);
    Serial.print(", port ");
    Serial.println(udp.remotePort());

    // read the packet into packetBufffer
    int len = udp.read(packetBuffer, 255);
    if (len > 0) {
      packetBuffer[len] = 0;
    }
    Serial.println("Contents:");
    Serial.println(packetBuffer);
  }
}

bool compareCardUID(byte *buffer, byte bufferSize)
{
    byte i = 0;
    bool retVal = true;

    for(i = 0; i < bufferSize; i++)
    {
        if (buffer[i] != card_uid[i])
        {
            retVal = false;
            break;
        }
    }

    return retVal;
}

void setRelayEnable(bool enable)
{
  if (enable)
  {
    ledCtrlData = (ledCtrlData & 0x07) | (0x03 << 3);
  }
  else
  {
    ledCtrlData = ledCtrlData & (~(0x03 << 3));
  }
}

void ledUpdate(void)
{

  switch(ledPos){
    case 0: ledData = number[washTime / 100]; break;
    case 1: ledData = number[(washTime / 10 ) % 10]; break;
    //case 2: ledData = number[washTime % 10]; break;
  }

  ledCtrlData = (1 << ledPos) | (ledCtrlData & 0xF8);

  if (++ledPos >= 3) ledPos = 0;

  // push out data
  digitalWrite(LATCH_PIN, LOW);
  shiftOut(DATA_PIN, CLK_PIN, ledCtrlData);
  shiftOut(DATA_PIN, CLK_PIN, ledData);
  digitalWrite(LATCH_PIN, HIGH);
}

void shiftOut(int myDataPin, int myClockPin, byte myDataOut) {
  // This shifts 8 bits out MSB first,
  //on the rising edge of the clock,
  //clock idles low

  int i=0;
  int pinState;

  pinMode(myClockPin, OUTPUT);
  pinMode(myDataPin, OUTPUT);

  digitalWrite(myDataPin, 0);
  digitalWrite(myClockPin, 0);

  for (i=7; i>=0; i--)  {
    digitalWrite(myClockPin, 0);

    if ( myDataOut & (1<<i) ) {
      pinState= 1;
    }
    else {
      pinState= 0;
    }

    //Sets the pin to HIGH or LOW depending on pinState
    digitalWrite(myDataPin, pinState);
    //register shifts bits on upstroke of clock pin
    digitalWrite(myClockPin, 1);
    //zero the data pin after shift to prevent bleed through
    digitalWrite(myDataPin, 0);
  }

  //stop shifting
  digitalWrite(myClockPin, 0);
}
